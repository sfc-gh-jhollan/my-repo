import numpy as np
from ._utilities import _check_fitted, _verify_input
__all__ = [
    "udf_minmax_transform",
    "udf_minmax_inverse_transform",
    "udf_standard_transform",
    "udf_standard_inverse_transform",
    "udf_maxabs_transform",
    "udf_maxabs_inverse_transform",
    "udf_robust_transform",
    "udf_robust_inverse_transform",
    "udf_normalizer_transform",
    "udf_binarizer_transform",
]


def udf_minmax_transform(X, encoder):
    """
        {'encoder': 'MinMaxScaler',
         'nbr_features': 2,
         'input_features': ['MedInc', 'AveOccup'],
         'fitted_values': {'min': [0.4999, 0.6923076923076923],
          'max': [15.0001, 1243.333333333333],
          'min_': [2.931049226907215, 2.998885747890143],
          'range': [14.5002, 1242.641025641026],
          'scale': [0.1379291320119723, 0.001609475269793451]}}

    :param X:
    :param encoder: Dictionary generated by the get_udf_encoder method of MinMaxScaler
    :return:
    """
    _check_fitted('MinMaxScaler', encoder)


    # Verify that X is a list of lists
    #if not any(isinstance(i, list) for i in X):
    #    raise TypeError("X needs to be a list of lists.")

    # Make sure it is an array with as many elements as the fit_settings
    fitted_values = encoder["fitted_values"]

    if not isinstance(X, np.ndarray):
        X = np.array(X)

    nested_array = True
    if X.ndim == 1:
        X = np.expand_dims(X, axis=0)
        # We need to convert it to a list of list, but be able to go back
        nested_array = False

    _verify_input(X, encoder["nbr_features"])

    scale_ = np.asarray(fitted_values["scale"])
    min_ = np.asarray(fitted_values["min_"])

    X *= scale_
    X += min_

    return X


def udf_minmax_inverse_transform(X, encoder):
    _check_fitted('MinMaxScaler', encoder)

    fitted_values = encoder["fitted_values"]

    if not isinstance(X, np.ndarray):
        X = np.array(X)

    nested_array = True
    if X.ndim == 1:
        X = np.expand_dims(X, axis=0)
        # We need to convert it to a list of list, but be able to go back
        nested_array = False

    _verify_input(X, encoder["nbr_features"])

    scale_ = np.asarray(fitted_values["scale"])
    min_ = np.asarray(fitted_values["min_"])

    X -= min_
    X /= scale_

    return X


def udf_standard_transform(X, encoder):
    # Make sure it is an array with as many elements as the fit_settings
    # Verify that X is a list of lists
    _check_fitted('StandardScaler', encoder)

    fitted_values = encoder["fitted_values"]

    _verify_input(X, encoder["nbr_features"])

    mean_ = np.asarray(fitted_values["mean"])
    X -= mean_
    scale_ = np.asarray(fitted_values["scale"])
    X /= scale_
    return X


def udf_standard_inverse_transform(X, encoder):
    # Make sure it is an array with as many elements as the fit_settings
    # Verify that X is a list of lists
    _check_fitted('StandardScaler', encoder)

    fitted_values = encoder["fitted_values"]

    _verify_input(X, encoder["nbr_features"])

    scale_ = np.asarray(fitted_values["scale"])
    X *= scale_

    mean_ = np.asarray(fitted_values["mean"])
    X += mean_

    return X


def udf_maxabs_transform(X, encoder):
    _check_fitted('MaxAbsScaler', encoder)

    fitted_values = encoder["fitted_values"]

    _verify_input(X, encoder["nbr_features"])

    scale_ = np.asarray(fitted_values["scale"])
    X /= scale_

    return X


def udf_maxabs_inverse_transform(X, encoder):
    _check_fitted('MaxAbsScaler', encoder)

    fitted_values = encoder["fitted_values"]

    _verify_input(X, encoder["nbr_features"])

    scale_ = np.asarray(fitted_values["scale"])
    X *= scale_

    return X


def udf_robust_transform(X, encoder):
    _check_fitted('RobustScaler', encoder)

    fitted_values = encoder["fitted_values"]

    _verify_input(X, encoder["nbr_features"])

    scale_ = np.asarray(fitted_values["scale"])
    center_ = np.asarray(fitted_values["center"])

    X -= center_
    X /= scale_

    return X


def udf_robust_inverse_transform(X, encoder):
    _check_fitted('RobustScaler', encoder)

    fitted_values = encoder["fitted_values"]

    _verify_input(X, encoder["nbr_features"])

    scale_ = np.asarray(fitted_values["scale"])
    center_ = np.asarray(fitted_values["center"])

    X *= scale_
    X += center_

    return X


def udf_normalizer_transform(X, encoder):
    #
    _check_fitted('Normalizer', encoder)

    fitted_values = encoder["fitted_values"]

    _verify_input(X, encoder["nbr_features"])

    norm = fitted_values["norm"]
    if norm == "l1":
        norms = np.abs(X).sum(axis=1)
    elif norm == "l2":
        norms = np.einsum("ij,ij->i", X, X)
        np.sqrt(norms, norms)
    elif norm == "max":
        norms = np.max(abs(X), axis=1)

    X /= norms[:, np.newaxis]

    return X


def udf_binarizer_transform(X, encoder):
    #
    _check_fitted('Binarizer', encoder)

    fitted_values = encoder["fitted_values"]

    _verify_input(X, encoder["nbr_features"])

    threshold = fitted_values["threshold"]
    X = np.array(X)
    cond = X > threshold
    not_cond = np.logical_not(cond)
    X[cond] = 1
    X[not_cond] = 0

    return X
